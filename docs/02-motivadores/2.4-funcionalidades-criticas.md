# Funcionalidades Críticas

Las funcionalidades críticas son las operaciones esenciales con restricciones funcionales. A continuación, se listan con su tipo, descripción y tácticas/estrategias:

| Tipo de funcionalidad crítica | Tipo especificación funcionalidad crítica | Descripción | Táctica/Estrategia (Nombre táctica) | Descripción estrategia |
|-------------------------------|-------------------------------------------|-------------|-------------------------------------|------------------------|
| Reto técnico | Requerimiento funcional | REQ-FUN-001 - El sistema debe permitir válidar la que la dirección de correo electronico si exista y le pertenesca al usuario, debe enviar un código de verificación al correo electrónico, para habilitar el acceso a la plataforma. | Implementación de Firebase Auth | Firebase Auth garantiza que los usuarios puedan registrarse y verificar su cuenta de manera segura, rápida y confiable. Esto delega la complejidad de la gestión de usuarios y la seguridad de contraseñas a una plataforma especializada, permitiendo que el desarrollo se enfoque en la lógica de negocio de Nexa. Un plus es que nexa va a usar servicio de storage ne firebase. |
| Reto técnico | Requerimiento funcional | REQ-FUN-002 - El sistema debe detectar automáticamente cuando un usuario no ha realizado el pago de su suscripción en la fecha límite establecida. | Integración con el sdk de Stripe para suscripciones | Se integra Stripe Billing para gestionar las suscripciones de los usuarios. Stripe notifica automáticamente al sistema cuando un pago falla o expira. Esta estrategia garantiza automatización total, seguridad en los pagos y protección del modelo de negocio, sin necesidad de verificar manualmente cada transacción. |
| Impacto o promesa de valor para el negocio | Requerimiento funcional | REQ-FUN-003 - El sistema debe cambiar el estado de todas las tiendas pertenecientes a un usuario de acuerdo al estado de su suscripción. | Manejo de estados en base de datos/ sdk Stripe | De acuerdo al estado de la suscripción de un usuario se debe poder actualizar el estado de sus tiendas asociadas en la base de datos. |
| Impacto o promesa de valor para el negocio | Requerimiento funcional | REQ-FUN-004 - El usuario debe recibir una notificación automática por correo electrónico, que informe la causa de la suspensión de su cuenta. | Integración con la API de Mailgun | Se utilizará la API de Mailgun en el backend para enviar correos electrónicos de forma programática. Cuando se active la lógica de suspensión, el sistema de Nexa invocará la API de Mailgun con los datos del usuario. El correo contendrá un mensaje predefinido que explicará la razón del impago y las instrucciones claras para reactivar la suscripción. |
| Impacto o promesa de valor para el negocio | Requerimiento funcional | REQ-FUN-005 - El sistema debe permitir que un usuario pueda reactivar su suscripción manualmente a través de un proceso de pago iniciado en la sección "Suscripción". | Integración de Flujo de Pago con Stripe | Se implementará un flujo de pago con el SDK de Stripe que, al seleccionar un plan gestiona todo el proceso. Esto simplifica el proceso de compra y delega a Stripe la responsabilidad de manejar los datos sensibles de la tarjeta y la confirmación del pago. Al completarse exitosamente, Stripe enviara una confirmación para activar la lógica de reactivación. |
| Impacto o promesa de valor para el negocio | Requerimiento funcional | REQ-FUN-006 - El sistema debe enviar una confirmación automática por correo electrónico al usuario una vez que su suscripción ha exitosa. | Integración con la API de Mailgun | Se utilizará la API de Mailgun para enviar correos. El backend de Nexa invocará la API con el correo del usuario y el contenido del mensaje de confirmación. Este correo sirve como prueba tangible para el usuario de que su pago fue procesado exitosamente y que su cuenta y tiendas han sido reactivadas, lo que genera confianza y cumple con un estándar de servicio profesional. |
| Impacto o promesa de valor para el negocio / Reto técnico | Requerimiento funcional | REQ-FUN-007 - El sistema debe permitir la creación de una tienda, generando al mismo tiempo la suscripción ligada al pago inicial. | Integración con Stripe y Gestión en Base de Datos | Se implementará una lógica de negocio que asocia la creación de la tienda con un flujo de pago orquestado por la API de Stripe. Al crear la tienda en la base de datos, el sistema le asignará un estado inicial de "pendiente". Posteriormente, se generará una sesión de pago con Stripe. Solo al recibir la confirmación de pago exitoso (a través de un webhook de Stripe), el sistema actualizará el estado de la tienda en la base de datos de "pendiente" a "activa", completando así el proceso. |
| Impacto o promesa de valor para el negocio | Requerimiento funcional | REQ-FUN-008 - El sistema debe permitir al usuario debe poder activar o desactivar su tienda manualmente desde el panel de control. Al desactivar, la tienda y su contenido dejan de ser visibles públicamente, pero no se eliminan los datos. | Implementación de un sistema de estados de las tiendas en base de datos | Se añadirá un campo estado a la entidad Tienda en la base de datos. La interfaz de usuario (UI) en el panel de control del usuario tendrá un botón o interruptor para cambiar este estado. La lógica del backend validará el cambio de estado y lo actualizará en la base de datos, lo que a su vez hará que la tienda sea o no visible en el frontend público. |
| Impacto o promesa de valor para el negocio | Requerimiento funcional | REQ-FUN-009 - El cliente puede agregar productos al carrito. El contenido del carrito debe guardarse localmente hasta que se envíe. | Persistencia híbrida del carrito: almacenamiento local para usuarios no registrados y sincronización con el backend(Redis)para usuarios registrados. | "Mientras el usuario no está registrado ni ha iniciado sesión, Nexa guarda los productos del carrito en el navegador usando LocalStorage. Esto permite que el cliente mantenga su selección aunque recargue la página o cierre la pestaña. Sin embargo, esta información solo vive en ese navegador: si el cliente cambia de dispositivo o borra la memoria local, el carrito se pierde. Para mejorar esta experiencia, al momento en que el cliente decide registrarse o iniciar sesión, el sistema ofrece sincronizar el carrito local con el backend. En ese momento, los productos guardados en LocalStorage se envían a Redis, donde se almacenan de forma rápida y temporal, pero ahora asociados al UID del usuario autenticado. Redis permite que el carrito esté disponible desde cualquier dispositivo. Desde ese punto en adelante, cualquier cambio en el carrito se actualiza directamente en Redis, y el cliente puede recuperar su selección desde cualquier lugar. Esta transición es fluida: el usuario no pierde lo que ya había seleccionado, y el sistema le deja claro que al registrarse obtiene una experiencia más confiable y sincronizada" |
| Reto técnico | Requerimiento funcional | REQ-FUN-010 - El sistema debe enviar el contenido del carrito de compras al vendedor vía WhatsApp, incluyendo la lista de productos y sus detalles. | Generación de URL de WhatsApp | Se implementará una función en el frontend que, al hacer clic en el botón de "Enviar por WhatsApp", recopilará los detalles de cada producto en el carrito. Luego, creará el mensaje que contenga la lista de productos, cantidades y precios. Este mensaje dinámico será el que se incluya en el enlace de WhatsApp, asegurando que el vendedor reciba de forma precisa el pedido completo. |
| Reto técnico | Requerimiento funcional | REQ-FUN-011 - El sistema debe mostrar métricas clave para la tienda, considerando únicamente las ventas en estado entregada. | Event-Driven + Vistas Materializadas | Cada vez que una venta se marca como entregada, el sistema genera un evento. Ese evento actualiza una tabla o vista especial que guarda las métricas ya calculadas (ej. ingresos acumulados, productos top, cliente top). Así, cuando el administrador abre el panel, el sistema no tiene que calcular nada en ese momento, solo mostrar los resultados ya listos y actualizados automáticamente. |
| Reto técnico | Requerimiento funcional | REQ-FUN-012 - El sistema debe manejar automáticamente el procesamiento de imágenes (optimización, versiones, cacheo y validación de seguridad). | Procesamiento de imágenes en el backend | Se implementará un proceso de fondo en el backend para manejar las imágenes subidas. Este proceso forzará la conversión al formato WebP o AVIF con una calidad del 75-80%, redimensionando la imagen a un tamaño máximo predefinido. Además, creará dos versiones adicionales: una principal y una miniatura (thumbnail). Todas las imágenes procesadas se suben a un servicio de almacenamiento en la nube (como Firebase Storage), y se sirven a través de la CDN integrada de Vercel, lo que garantiza una entrega rápida y eficiente a nivel global. Antes del procesamiento, se validará que el archivo corresponda exclusivamente a formatos de imagen permitidos (como JPG, PNG, WebP o AVIF), rechazando cualquier extensión extraña o no compatible para garantizar seguridad y consistencia en el flujo. Asimismo, se eliminarán caracteres especiales o no estándar en el nombre del archivo, generando un identificador limpio y seguro que permita persistir la imagen sin riesgos ni ambigüedades en el almacenamiento. |

## Detalles de Implementación

### Validación de Correo (REQ-FUN-001)
Firebase Auth garantiza verificación segura y confiable de cuentas.

### Gestión de Pagos (REQ-FUN-002)
Stripe Billing maneja suscripciones y notifica automáticamente fallos.

### Estado de Tiendas (REQ-FUN-003)
Actualización automática basada en estado de suscripción.

### Notificaciones (REQ-FUN-004/006)
Mailgun envía correos transaccionales de forma programática.

### Suscripciones (REQ-FUN-005/007)
Flujo integrado con Stripe para pagos y activación de tiendas.

### Control de Tienda (REQ-FUN-008)
Sistema de estados en base de datos con UI de control.

### Carrito (REQ-FUN-009)
Sistema híbrido: LocalStorage + Redis para sincronización.

### WhatsApp (REQ-FUN-010)
Generación dinámica de mensajes y enlaces.

### Métricas (REQ-FUN-011)
Sistema event-driven con vistas precalculadas.

### Imágenes (REQ-FUN-012)
Procesamiento automático con optimización y CDN.